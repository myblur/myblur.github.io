<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从零开始写一个RPC框架——一切从这里开始]]></title>
    <url>%2F%2Farticles%2Fwrite-an-rpc-from-scratch-part-one.html</url>
    <content type="text"><![CDATA[RPC，这个名词在我上学及找工作的的几年前是比较少能谈及到的，我也是工作之后才第一次接触到RPC框架Dubbo（其实也不能这么说，Http也可以算作RPC）。 匆匆几年，不知什么时候RPC这个名词已经是招聘JD里面的常客了？ RPC是什么？RPC是什么，第一次用Dubbo的时候我也是很懵逼的。 受当时的知识面所局限，我在最开始的接触的Dubbo时一直很不理解为什么我只是用定义的接口调用了一个方法，远端的服务就能接收到我的请求并处理然后响应结果。 后来使用了Debug大法才恍然大悟，原来还能这么玩。 下面引用一段网上经典的描述及图片来对RPC做一个简单的理解。 RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 RPC事件顺序 客户端（client function）调用客户端存根（client stub，可以理解为一个代理）。该调用是本地过程调用。 客户端存根（client stub）将参数打包到消息中，并进行系统调用以发送消息。 客户端的操作系统将消息从客户端计算机发送到服务器计算机。 服务器的操作系统将传入的数据包传递到服务器存根（server stub，可以理解为一个代理）。 服务器存根（server stub）解包消息得到调用参数。 服务器存根（server stub）调用真实的服务（server function）获得结果并以相同的方式反向返回结果。 RPC框架的基本实现根据上面的理论我们大致知道一个RPC框架该怎么去实现。 对于一个0.0.1版本的RPC框架，我们的需求不多，只要能够调用成功服务端并能成功返回结果就OK。 RPC服务端的实现首先我们需要写一个服务端，暂时使用BIO来处理网络通信，并且支持多线程处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class RpcServer &#123; /** * 服务端绑定的IP */ private String host; /** * 服务端绑定的端口 */ private int port; private ServerSocket server; /** * RPC服务映射，不支持一个服务接口有多个服务实现 * 服务接口类名 =&gt; 服务接口实现类 */ private final ConcurrentMap&lt;String, Object&gt; serviceMappings = new ConcurrentHashMap&lt;&gt;(); /** * RpcServer的运行状态 */ private volatile boolean running = false; public RpcServer(String host, int port) &#123; this.host = host; this.port = port; &#125; /** * 启动服务端，并监听客户端Socket的连接请求 * * @throws IOException */ public void startServer() throws IOException &#123; // 注册一个ShutdownHook，用于在应用关闭时来调用RpcServer的关闭逻辑 Runtime.getRuntime().addShutdownHook(new Thread(RpcServer.this::stop)); server = new ServerSocket(); server.bind(new InetSocketAddress(this.host, this.port)); System.out.println("服务器启动成功，绑定地址：" + this.server.getLocalSocketAddress()); running = true; while (running) &#123; try &#123; Socket socket = this.server.accept(); System.out.println("接收到客户端连接：" + socket); new Thread(new RequestHandler(socket), "RequestHandler[" + socket.getRemoteSocketAddress().toString() + "] Thread").start(); &#125; catch (IOException e) &#123; System.out.println("接收连接异常：" + e); &#125; &#125; &#125; /** * 关闭RpcServer */ public void stop() &#123; System.out.println("服务器关闭"); running = false; try &#123; this.server.close(); &#125; catch (Exception e) &#123; System.out.println("服务器关闭异常：" + e); &#125; &#125; /** * 注册一个接口服务 * RPC服务接口 =&gt; RPC接口服务实例 * * @param interfaceClass RPC接口服务类 * @param serviceObject RPC接口服务实例 */ public void addServiceMapping(Class&lt;?&gt; interfaceClass, Object serviceObject) &#123; if (null != serviceMappings.get(interfaceClass.getName())) &#123; throw new RpcException("接口[" + interfaceClass.getName() + "]已经存在一个实现"); &#125; System.out.println("注册RPC服务[" + interfaceClass.getName() + " =&gt; " + serviceObject + "]"); this.serviceMappings.put(interfaceClass.getName(), serviceObject); &#125; /** * 客户端请求处理 */ private final class RequestHandler implements Runnable &#123; // 客户端请求处理。。。 &#125;&#125; 上面的代码可能有人会疑惑RpcServer#addServiceMapping()方法是干什么用的，我们先暂时放下RequestHandler这个类的实现，看看这个RpcServer我们应该怎么来启动。 123456789101112131415161718192021222324252627282930313233343536/** * 1. 定义一个RPC服务接口 */public interface HelloService &#123; String sayHello(String name);&#125;/** * 2. 实现HelloService接口 */public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return "Hello, " + name; &#125; &#125;/** * 3. 启动RpcServer，注册需要提供的Rpc服务与实例映射。 */public class Startup &#123; public static void main(String[] args) throws IOException &#123; // 1.设置RPC的监听地址与端口 RpcServer rpcServer = new RpcServer("localhost", 10210); // 2.服务启动前，注册要提供的RPC服务接口与RPC服务接口的实现 rpcServer.addServiceMapping(HelloService.class, new HelloServiceImpl()); // 3.启动服务 rpcServer.startServer(); &#125;&#125; 通过Startup#main()中的三个步骤就完成了RpcServer的启动，很显然RpcServer#addServiceMapping()就是用来将所有需要提供服务的接口添加一个mapping。 在RpcServer的代码中我们用RequestHander来处理服务端接收到Socket连接，RequestHandler主要职责有三：读取请求数据，调用服务目标方法，写出响应数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 客户端请求处理 */private final class RequestHandler implements Runnable &#123; private Socket socket; private ObjectInputStream in; private ObjectOutputStream out; RequestHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; RpcResponse rpcResponse = new RpcResponse(); try &#123; // 读取数据 RpcRequest rpcRequest = readData(); // 调用服务，暂时忽略自定义的异常及下面的异常处理 Object result = invokeService(rpcRequest); // 写出数据 rpcResponse.setResponse(result); writeData(rpcResponse); &#125; catch (IOException e) &#123; System.out.println("从Socket中读取或写入数据异常：" + e); &#125; catch (Exception e) &#123; rpcResponse.setThrowable(e); try &#123; writeData(rpcResponse); &#125; catch (IOException ie) &#123; System.out.println("服务端响应数据异常：" + ie); &#125; &#125; finally &#123; IOUtils.close(this.socket, this.in, this.out); &#125; &#125; /** * 将响应结果写出 * * @param response 响应结果 * @throws IOException 写出结果发生异常 */ private void writeData(RpcResponse response) throws IOException &#123; out = new ObjectOutputStream(this.socket.getOutputStream()); out.writeObject(response); out.flush(); &#125; /** * 从Socket中读取数据 * * @return Rpc请求 * @throws IOException 读取数据异常 * @throws ClassNotFoundException Rpc请求，或者Rpc请求中所带的class在服务端不存在 */ private RpcRequest readData() throws IOException, ClassNotFoundException &#123; this.in = new ObjectInputStream(this.socket.getInputStream()); return (RpcRequest) in.readObject(); &#125; /** * 调用服务的方法 * * @param rpcRequest Rpc请求 * @return 调用结果 */ private Object invokeService(RpcRequest rpcRequest) &#123; Object serviceObject = serviceMapping.get(rpcRequest.getInterfaceClassName()); if (null == serviceObject) &#123; throw new NotFoundServiceException("服务类[" + rpcRequest.getInterfaceClassName() + "]没有找到可用的服务"); &#125; try &#123; Method method = serviceObject.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterTypes()); return method.invoke(serviceObject, rpcRequest.getArguments()); &#125; catch (NoSuchMethodException | SecurityException e) &#123; throw new NotFoundServiceException("服务类[" + rpcRequest.getInterfaceClassName() + "]没有找到目标方法", e); &#125; catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; throw new NotFoundServiceException("服务类[" + rpcRequest.getInterfaceClassName() + "]调用目标方法异常", e); &#125; &#125;&#125; RPC客户端的实现如何实现客户端，让调用方在无感知的情况下就能实现RPC远程调用呢？我们可以使用JDK提供的动态代理来实现调用方的无感知的远程调用。 1234567891011121314151617181920212223242526272829303132/** * 使用JDK动态代理来无感知的完成RPC调用的内部细节 */public class RpcInvocationHandler implements InvocationHandler &#123; private RpcInvoker&lt;?&gt; invoker; public RpcInvocationHandler(RpcInvoker&lt;?&gt; invoker) &#123; this.invoker = invoker; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); // 排除掉所有定义在Object.class的方法，已经toString、hashCode、equals方法 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(invoker, args); &#125; if ("toString".equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123; return invoker.toString(); &#125; if ("hashCode".equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123; return invoker.hashCode(); &#125; if ("equals".equals(methodName) &amp;&amp; parameterTypes.length == 1) &#123; return invoker.equals(args[0]); &#125; return invoker.invoke(methodName, parameterTypes, args); &#125;&#125; RpcInvocationHandler有个细节要处理，排除掉所有定义在Object.class中的方法，比如Object#wait()、Object#notify()等，还要排除invoker中重写的toString，hashCode，equals方法。 在上面的RpcInvocationHandler构造方法中我们传入了一个叫做RpcInvoker（RPC调用者？）的对象，其实它封装了一系列的RPC调用的内部处理细节（当然现在里面其实没做太多的事情。。。）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * RPC调用者？？？ */public class RpcInvoker&lt;T&gt; &#123; /** * RPC客户端 */ private RpcClient rpcClient; /** * 接口服务类 */ private Class&lt;T&gt; interfaceClass; /** * 构造一个RpcInvoker * * @param host RPC服务器端监听host * @param port RPC服务器端监听的port * @param interfaceClass 目标服务接口类 */ public RpcInvoker(String host, int port, Class&lt;T&gt; interfaceClass) &#123; this.rpcClient = new RpcClient(host, port); this.interfaceClass = interfaceClass; &#125; /** * @param methodName 方法名 * @param parameterTypes 参数类型 * @param args 方法参数 * @return 结果 * @throws Throwable 服务端及客户端异常，包括RPC服务抛出的异常 */ public Object invoke(String methodName, Class&lt;?&gt;[] parameterTypes, Object[] args) throws Throwable &#123; RpcResponse rpcResponse = null; try &#123; // 实例化一个RpcRequest RpcRequest rpcRequest = new RpcRequest().newRpcRequest(this.interfaceClass.getName(), methodName, parameterTypes, args); // 通过RPC Client将数据发送到RPC Server this.rpcClient.writeData(rpcRequest); // 从RPC Server读取响应结果 rpcResponse = (RpcResponse) this.rpcClient.readData(); &#125; finally &#123; this.rpcClient.close(); &#125; // 异常处理 if (null == rpcResponse) &#123; throw new RpcException("RPC调用为获取到结果"); &#125; if (null != rpcResponse.getThrowable()) &#123; throw rpcResponse.getThrowable(); &#125; // 返回真实结果给服务调用方 return rpcResponse.getResponse(); &#125;&#125;/** * RPC客户端，负责收发数据，此处使用短连接，及每一次RPC调用都是一个新的Socket */public class RpcClient &#123; private Socket socket; private ObjectOutputStream out; private ObjectInputStream in; public RpcClient(String host, int port) &#123; this.socket = new Socket(); try &#123; this.socket.connect(new InetSocketAddress(host, port), 3000); &#125; catch (Exception e) &#123; throw new RpcNetworkException("连接服务器[" + host + ":" + port + "]异常", e); &#125; &#125; /** * 写数据 * * @param object 数据 * @throws IOException 写出异常 */ public void writeData(Object object) throws IOException &#123; this.out = new ObjectOutputStream(this.socket.getOutputStream()); this.out.writeObject(object); this.out.flush(); &#125; /** * 读数据 * * @return 读去结果 * @throws IOException 读取异常 * @throws ClassNotFoundException 返回的结果的class在客户端不存在 */ public Object readData() throws IOException, ClassNotFoundException &#123; this.in = new ObjectInputStream(this.socket.getInputStream()); return this.in.readObject(); &#125; public void close() &#123; IOUtils.close(this.in, this.out, this.socket); &#125;&#125; 我们以HelloService这个RPC接口服务为例来使用一下这个简单的RPC实现。 123456789101112131415public class Startup &#123; public static void main(String[] args) &#123; // 实例化一个RpcInvoker RpcInvoker&lt;HelloService&gt; invoker = new RpcInvoker&lt;&gt;("localhost", 10210, HelloService.class); // 使用JDK动态代理来得到HelloService HelloService helloService = (HelloService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[]&#123;HelloService.class&#125;, new RpcInvocationHandler(invoker)); // 调用sayHello方法 final String result = helloService.sayHello("Simple RPC"); // 打印结果 System.out.println("结果：" + result); &#125;&#125; 数据是怎样交互的从上面RequestHandler中可以看出，读取数据的时用的ObjectInputStream读取，直接将对象装换成一个RpcRequest，写出数据时也是将结果包装成一个RpcResponse用ObjectOutputStream写出，那么这两个类具体有什么呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// ============================== RpcRequest ==============================/** * RPC请求，网络传输需要实现Serializable接口 */public class RpcRequest implements Serializable &#123; private static final long serialVersionUID = -9213158787762981233L; /** * 目标接口类 */ private String interfaceClassName; /** * 目标接口方法名 */ private String methodName; /** * 目标接口方法参数类型 */ private Class&lt;?&gt;[] parameterTypes; /** * 目标接口方法参数 */ private Object[] arguments; // 省略getter setter方法&#125;// ============================== RpcResponse ==============================/** * RPC响应，网络传输需要实现Serializable接口 */public class RpcResponse implements Serializable &#123; private static final long serialVersionUID = -5573289211420999714L; /** * 响应结果 */ private Object response; /** * 服务端的异常，包括服务方法抛出的异常 */ private Throwable throwable; /** * @return the response */ public Object getResponse() &#123; return response; &#125; /** * @param response the response to set */ public void setResponse(Object response) &#123; this.response = response; &#125; /** * @return the throwable */ public Throwable getThrowable() &#123; return throwable; &#125; /** * @param throwable the throwable to set */ public void setThrowable(Throwable throwable) &#123; this.throwable = throwable; &#125;&#125; RpcRequest中的interfaceClassName、methodName、parameterTypes三个成员属性就能确定一个服务类的方法，这三者可被称作“RPC服务三元组”。而arguments则承载着这个方法的调用参数。 RpcResponse则有repsonse、throwable两个成员属性，前者是RPC服务真实的调用结果，后者则包括了一系列的异常，如客户端异常、服务端异常、RPC服务抛出的异常。 客户端将RpcRequest序列化后通过网络传输到服务端，服务端接收到RpcRequest，通过“RPC服务三元组”找到目标服务方法，执行此方法得到结果，并将调用结果包装成RpcResponse序列化后写回给客户端，客户端接收数据后获取调用结果，就能得到RPC调用的结果。 据我有限的知道的几款RPC框架如Dubbo、Motan、sofa-rpc等都是基于此种最基本的形式来完成远程调用。 总结通过上面的代码我们基本上完成了一个脆弱的RPC框架 当然这是一个v0.0.1版本的RPC框架，我们还有很多事情需要做，比如NIO、服务发现、异常处理、资源控制、优雅关机等等一系列问题。 这些问题容我来慢慢的各个击破。 下次再见。。。]]></content>
      <categories>
        <category>分布式基础</category>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka常见面试题及简要解答（上篇）]]></title>
    <url>%2F%2Farticles%2Fkafka-interview-questions-and-answers-part-one.html</url>
    <content type="text"><![CDATA[这段时间京东的技术类书各种满多少减多少，小组老司机说这个月的活动经费不吃饭了，买书吧！ 鞥。。。实在是我的书太多了，经典的书基本上都买了，不知道我还能买些什么。。。 不过有句话说的好：书非借不能读也！我的书基本上在吃灰。 不过最后还是买了两本：《Rust编程之道》、《深入理解Kafka核心设计与实践原理》。前者暂时不表，之所以买后者呢，是因为一直也没深入学过Kafka，关注过后者的作者的微信公众号，前段时间推了一篇Kafka面试题全套整理 | 划重点要考！，看了里面的题目，感觉一脸懵逼，既然他又写了本书，那就买来看看吧。。。 啰嗦了这么多，开始正题吧，接下来我将会把文章里面所列出的题目都一一简要作答，以供参考。 Kafka的用途有哪些？使用场景如何？ 消息系统：可以当做传统消息中间件，并且提供了大多数消息系统难以实现的消息顺序性保障及回溯消息功能。 存储系统：Kafka的消息持久化到硬盘进行存储，并且是多副本存储。我们可以设置数据保留策略为”永久”来作为长期数据存储系统来使用。 流处理平台：Kafka提供了一个完整流式处理类库，比如窗口，连接，变换和聚合等操作。 Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么？ ISR(In-Sync Replicas)：所有与leader副本保持一定程度同步的副本组成ISR，ISR集合是AR集合中的一个子集。 AR(Assigned Replicas)：分区中所有副本系统的成为AR。 ISR的伸缩：leader副本负责维护与跟踪ISR集合中所有follower副本的滞后程度，当follower副本落后太多或者失效是，leader副本会将他从ISR集合中剔除并加入OSR中，如果OSR集合中有follower副本”追上”了leader副本，那么leader副本会把它从OSR集合中转移到ISR集合。 一定程度同步：Kafka消息生产者发送的消息首先会先发送到leader副本，然后follower副本才能从leader副本中拉取消息进行同步，同步期间follower副本相对于leader副本会有一定程度的之后，而这个滞后返回可以通过参数配置。而滞后超过这个配置的则组成OSR(Out-of-Sync Replicas) Kafka中的HW、LEO、LSO、LW等分别代表什么？ HW(High Watermark)：俗称高水位，它标识一个特定的消息偏移量（offset），消费者只能拉取到这个offset之前的消息。 LEO(Log End Offset)：它标识当前日志文件中下一条代写入消息的offset，相当于当前日志分区中最后一条消息的offset+1，分区ISR集合中每个副本都会维护自身的LEO，而ISR集合中最小的LEO及为分区的HW，而消费者也只能消费HW之前的消息。 Kafka中是怎么体现消息顺序性的？ Kafka的消息有序通过offset提现，offset是消息在分区中的唯一标识，Kafka通过offset保证消息在分区内的有序性，但是offset不能跨越分区，所以Kafka的消息有序性只体现在分区有序而不是主题有序。 Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？ 分区器：计算消息即将发送到的分区号，Kafka提供了默认的分区器，分区规则：如果消息的key不为null，那么对key进行hash（使用MurmurHash2算法，具备高性能及低碰撞率），根据最终得到的hash值来计算分区号；若key为null，那么消息将会Yui轮询的方式发送到主题内的各个可用分区。 序列化器：生产者需要序列化器将对象序列化字节数组才能通过网络发送给Kafka，而消费者需要反序列化器把从Kafka中接收到的字节数组转换成对应的对象。 处理顺序：拦截器-&gt;序列化器-&gt;分区器。 Kafka生产者客户端的整体结构是什么样子的？ Kafka生产者客户端整体架构简要概述：整个生产者客户端由两个线程协调运行，分别为主线程和Sender线程，主线程中油KafkaProducer创建消息，然后通过拦截器-&gt;序列化器-&gt;分区器的处理之后交给消息累加器（RecordAccumulator，也称为消息收集器），Sender线程负责从RecordAccumulator中获取消息并将其发送到Kafka中。 Kafka生产者客户端中使用了几个线程来处理？分别是什么？ 两个线程(其实应该算一个，调用send的那个线程照理来说不属于Kafka客户端)，业务线程调用KafkaProducer.send()方法，发送消息，经过拦截器-&gt;序列化器-&gt;分区器之后，将消息交给RecordAccumulator，Sender线程负责将消息发送到Kafka中。 Kafka的旧版Scala的消费者客户端的设计有什么缺陷？ 工作状态不明确：旧版消费者基于Zookeeper的Watcher来实现功能，每个消费者对相关的路径进行监听，当触发再均衡操作时，一个消费者组下的所有消费者会同时进行在均衡操作，而消费者之间并不知道彼此操作的结果，可能会导致Kafka工作在一个不正确的状态。 过度依赖Zookeeper集群： 羊群效应：Zookeeper中一个被监听的节点变化，大量的Watcher事件通知被发送到客户端，导致在通知期间的其他操作延迟，也可能发生死锁问题。 脑裂问题：消费者再均衡操作时，每个消费者都与Zookeeper进行通信以判断消费者或Broker变化的情况，由于Zookeeper本身的特性，可能导致同一时刻的消费者获取的状态不一致。 “消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？ 不正确。 自定义分区分配策略使一个分区可以分配给多个消费者消费（具体实现可以单独写一篇文章，这里就不再进行详细的叙述了）。 消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1? 当前消费者需要提交的offset并不是offset，而是offset+1，它标识下一条需要拉取消息的位置 有哪些情形会造成重复消费？ 一次拉取多条消息，消息全部处理完成再进行位移提交。若消费者在处理了部分消息之后异常宕机，则此时没有进行位移提交，故障恢复后消费者再次拉取的消息还是从宕机前最后一次提交的offset开始。此为重复消费消息。 那些情景下会造成消息漏消费？ 一次拉取多条消息，拉取消息之后马上进行了位移提交。消费者在处理了部分消息之后异常宕机，故障恢复之后拉取到的是已经位移提交之后的值，未处理的消息则被漏消费（漏处理）。 KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？ 如何实现多线程消费： 每一个消费线程单独持有一个KafkaConsumer对象，但是此方法线程数受限于分区的实际个数。 多个线程消费同一个分区，实现复杂，不推荐。 单线程接收消息，多线程处理消息，但此方法会导致消息无法顺序处理，手动位移提交需要特别设计。 KafkaConsumer定义了一个acquire方法，用来检查当前是否只有一个线程在操作，若有其他线程正在操作此KafkaConsumer，则会抛出ConcurrentModifcationException异常，其实现方式也异常简单，节选代码如下： 1234567891011121314151617181920212223242526// currentThread holds the threadId of the current thread accessing KafkaConsumer// and is used to prevent multi-threaded accessprivate static final long NO_CURRENT_THREAD = -1L;private final AtomicLong currentThread = new AtomicLong(NO_CURRENT_THREAD);/** * * 获取一个轻量级锁用来保证消费者在多线程下是线程安全的，如果锁已经被其他线程持有了则抛出 ConcurrentModificationException。 * 而这个锁的获取也挺简单，currentThread默认值为NO_CURRENT_THREAD，通过cas设置当前线程的值，若设置失败，则代表有其他线程已经在操作此KafkaConsumer，则抛出异常。*/private void acquire() &#123; long threadId = Thread.currentThread().getId(); if (threadId != currentThread.get() &amp;&amp; !currentThread.compareAndSet(NO_CURRENT_THREAD, threadId)) &#123; throw new ConcurrentModificationException("KafkaConsumer is not safe for multi-threaded access"); &#125; // 此处代表这个锁也是可重入的。 refcount.incrementAndGet();&#125;/** * 示范锁，当refcount减至0，则代表当前线程不再持有此KafkaConsumer*/private void release() &#123; if (refcount.decrementAndGet() == 0) currentThread.set(NO_CURRENT_THREAD);&#125; 简述消费者与消费组之间的关系。 若所有的消费者都属于同一个消费组，那么所有的消息都会被均衡的投递给每一个消费者，即每条消息知会被一个消费者处理，这就相当于“点对点”模式的应用 若所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息都会被所有的消费者处理，这就相当于“发布/订阅”模式的应用 当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？ 创建topic：Kafka在log.dir或者log.dirs参数所配置的目录下创建相应的主题分区，在zookeeper中创建/brokers/topics/{topic-name}、/config/topics/{topic-name}节点。 删除topic：删除Zookeeper中/config/topics/{topic-name}节点、删除/brokers/topics/{topic-name}几点及其子节点，删除Kafka集群中在log.dir或者log.dirs参数所配置的目录下所有与主题{topic-name}相关的文件。 topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？ 分区数可以增加。 通过topic-config.sh脚本中的alter命令进行分区增加操作。 topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？ 不支持分区数减少。 删除分区会引起一系列问题，比如消息的顺序性、事务性、以及分区和副本的状态机切换问题。 创建topic时如何选择合适的分区数？ 分区数的选择视具体情况而定。 增加合适的分区数可以在一定程度上提升整体的吞吐量，但超过对应的阈值之后吞吐量不升反降，建议在生成环境中做一个完备的测试找到合适分区数与阈值。 Kafka目前有那些内部topic，它们都有什么特征？各自的作用又是什么？ 截止至Kafka 2.0.0版本，Kafka内部保护两个主题：__consumer_offsets、__transaction_state __consumer_offsets用于存放存放消费者偏移量，__transcation_state用于持久化事务状态信息。 优先副本是什么？它有什么特殊的作用？ 优先副本是指在AR集合列表中第一个副本。 理想情况下，优先副本就是该分区的leader副本，Kafka会确保所有的主题的优先副本在集群中均匀分布 Kafka有哪几处地方有分区分配的概念？简述大致的过程及原理。 这题不太明白具体意思，到底是说Kafka的创建主题之后的brokers的分区分配，还是分区重分配的分区分配，还是消费者的分区分配。。。 暂且放这里。。。 简述Kafka的日志目录结构。 大致目录结构如下 此处应当有图 /{kafka-logs}/{topic-name}-{partition}/{index,log,timeindex} Kafka中有那些索引文件？ 有偏移量所有文件*.index和时间索引文件*.timeindex。 如果我指定了一个offset，Kafka怎么查找到对应的消息？ Kafka中的索引文件是稀疏索引，并不保证每个消息在索引文件中都有对应的索引项，offset索引文件是单调递增的，查询指定offset时，使用二分查找法来快速定位offset的位置，如果指定的offset不在索引文件中，则会返回喜爱与指定offset的最大offset。 如果我指定了一个timestamp，Kafka怎么查找到对应的消息？ timestamp的索引文件也保持严格的单调递增，同样使用二分查找法找到此timestamp对应的offset，再根据此offset去查找offset的索引文件再次定位。 聊一聊你对Kafka的Log Retention的理解。 按照一定的保留策略直接删除不符合条件的日志分段。 主要分为下面三种策略： 基于时间：日志删除任务会检查当前日志文件中是否有保留时间超过设定阈值的日志分段文件集合。阈值可以通过broker端参数log.retention.hours、log.retention.minutes和log.retention.ms来配置，优先级依次提高。默认情况只配置了log.retention.hours参数，其值为168，即日志分段文件的默认保留时间为7天。 基于日志大小：日志删除任务会检查当前日志文件中是否有文件大小超过设定阈值的日志分段文件集合。阈值可以通过broker端参数log.retention.bytes（此配置是Log中所有的日志文件的总大小）来配置，默认值为-1，表示无穷大；单个日志分段大小的配置为log.segment.bytes来限制，默认值为1073741824，即为1GB 基于日志起始偏移量：基于日志起始偏移量的保留策略的判断依据是某日志分段的下一个日志分段的起始偏移量baseOffset是否小于logStartOffset，若是则可以删除此日志分段。 聊一聊你对Kafka的Log Compaction的理解 针对每个消息的key进行整合，对于有相同的key，不同value值，只保留最后一个版本，下图为官方示意图（也可以新开一章详细叙述） 以上是部分面试题的简要解答，若有疏漏与错误之处还请谅解与指出，不胜感激。 下篇再见。。。]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全新的开始]]></title>
    <url>%2F%2Farticles%2Fbrand-new-start.html</url>
    <content type="text"><![CDATA[距离上一次折腾博客差不多有五年了吧。 当时发现原来还有静态博客这么好的东西，连夜搭建环境开搞。 第一篇文章就是将自己在Windows机器上用Octpress搭建静态博客并使用Github Pages部署的过程及所踩过的坑记录了下来，我的第一个域名iblur.me也是在那时候申请的。。。 然后，好像就没有然后了吧。。。 然后，突然发现没什么可值得写的了。。。 再后来觉得用Java写个博客程序也行，决定要秀一波，然后花了半个月用Java写了个博客程序，配上一个自己凑出来的UI，放在了现在已经下线的百度的BAE上面，然后又去做了备案，这一放就是三四年，每月12块，也挺好！ 这个博客也七七八八也写了一些现在看来”误人子弟”，”啼笑皆非”的文章，闲来无事读下来真是老脸都没处搁，幸好当年除了我自己也没人看。 当然咯，每年我还一定在12月31号那天上去写一篇当年的年终总结，顺便给自己定一些基本上来年实现不了的目标，周而复始。。。 就这样写了估计有三年吧。。。 这个博客程序当年一上线就说要做第二版，因为不fashion。。。 然后还拟定了如下需求： 前后台UI必须换，哪怕抄一个来。 上监控预警，监控CPU，Memory，GC，Thread，用图表动态展示，用邮件实时预警。 上统计分析，统计PV，浏览器类型，操作系统类型，地域分布。 根据阅读量统计标签热度，搞出类似标签云的东西来。 换Cache，EhCache还要占本机内存？BAE的Redis有限制性的免费用？必须上Redis。 搞前后端分离，template能装逼？必须用上高大上的React、AngularJS（那时Vue.js还不火）。 搜索怎能用数据库的like呢？必须用Lucene做全文搜索。 。。。 然后，这个v2.0就这么一拖也拖了三年。。。 那么我为什么现在突然又要弄博客了呢？ 我能说我买了两个域名一直没用，就勉强认为就是这个原因吧。。。 重新弄这个博客，也不打算自己再用Java重写了，毕竟前端是我的硬伤，就用Hexo弄个静态博客，先用Github Pages部署，至于要不要弄个单独的服务器部署再说吧！ 那博客要写什么了？其实我暂时也不太清楚，应该会包括学习心得、工作总结、读书笔记、个人生活、个人吐槽等等。。。 我的文笔非常不好，写起东西来口水话特别多，就通过这个博客来慢慢锻炼吧。。。 暂时就到这里吧。。。]]></content>
      <categories>
        <category>想法</category>
      </categories>
      <tags>
        <tag>琐碎</tag>
      </tags>
  </entry>
</search>
